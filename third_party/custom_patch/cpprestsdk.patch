diff --git a/Release/CMakeLists.txt b/Release/CMakeLists.txt
old mode 100644
new mode 100755
index 14e43ced..428e0038
--- a/Release/CMakeLists.txt
+++ b/Release/CMakeLists.txt
@@ -26,7 +26,7 @@ set(CPPREST_INSTALL ON CACHE BOOL "Add install commands.")
 if(IOS OR ANDROID)
   set(BUILD_SHARED_LIBS OFF CACHE BOOL "Build shared libraries")
 else()
-  set(BUILD_SHARED_LIBS ON CACHE BOOL "Build shared libraries")
+  set(BUILD_SHARED_LIBS OFF CACHE BOOL "Build shared libraries")
 endif()
 
 if(IOS OR ANDROID OR WINDOWS_STORE OR WINDOWS_PHONE)
diff --git a/Release/include/pplx/pplxtasks.h b/Release/include/pplx/pplxtasks.h
index 6868fc16..6b4d17b6 100644
--- a/Release/include/pplx/pplxtasks.h
+++ b/Release/include/pplx/pplxtasks.h
@@ -2514,7 +2514,7 @@ struct _Task_impl : public _Task_impl_base
             if (_M_Continuations)
             {
                 // Scheduling cancellation with automatic inlining.
-                _ScheduleFuncWithAutoInline([=]() { _RunTaskContinuations(); }, details::_DefaultAutoInline);
+                _ScheduleFuncWithAutoInline([=, this]() { _RunTaskContinuations(); }, details::_DefaultAutoInline);
             }
         }
         return true;
diff --git a/Release/src/http/listener/http_server_asio.cpp b/Release/src/http/listener/http_server_asio.cpp
index e83b9ff5..ae3d9e17 100644
--- a/Release/src/http/listener/http_server_asio.cpp
+++ b/Release/src/http/listener/http_server_asio.cpp
@@ -420,7 +420,7 @@ private:
     will_erase_from_parent_t do_response()
     {
         auto unique_reference = this->get_reference();
-        get_request().get_response().then([=](pplx::task<http_response> r_task) {
+        get_request().get_response().then([=, this](pplx::task<http_response> r_task) {
             http_response response;
             try
             {
@@ -434,7 +434,7 @@ private:
             serialize_headers(response);
 
             // before sending response, the full incoming message need to be processed.
-            return get_request().content_ready().then([=](pplx::task<http_request>) {
+            return get_request().content_ready().then([=, this](pplx::task<http_request>) {
                 (will_deref_and_erase_t) this->async_write(&asio_server_connection::handle_headers_written, response);
             });
         });
@@ -444,7 +444,7 @@ private:
     will_erase_from_parent_t do_bad_response()
     {
         auto unique_reference = this->get_reference();
-        get_request().get_response().then([=](pplx::task<http_response> r_task) {
+        get_request().get_response().then([=, this](pplx::task<http_response> r_task) {
             http_response response;
             try
             {
@@ -882,7 +882,7 @@ will_deref_t asio_server_connection::handle_chunked_body(const boost::system::er
     {
         auto writebuf = requestImpl->outstream().streambuf();
         writebuf.putn_nocopy(buffer_cast<const uint8_t*>(m_request_buf.data()), toWrite)
-            .then([=](pplx::task<size_t> writeChunkTask) -> will_deref_t {
+            .then([=, this](pplx::task<size_t> writeChunkTask) -> will_deref_t {
                 try
                 {
                     writeChunkTask.get();
@@ -947,13 +947,13 @@ will_deref_and_erase_t asio_server_connection::async_write(WriteFunc response_fu
 {
     if (m_ssl_stream)
     {
-        boost::asio::async_write(*m_ssl_stream, m_response_buf, [=](const boost::system::error_code& ec, std::size_t) {
+        boost::asio::async_write(*m_ssl_stream, m_response_buf, [=, this](const boost::system::error_code& ec, std::size_t) {
             (this->*response_func_ptr)(response, ec);
         });
     }
     else
     {
-        boost::asio::async_write(*m_socket, m_response_buf, [=](const boost::system::error_code& ec, std::size_t) {
+        boost::asio::async_write(*m_socket, m_response_buf, [=, this](const boost::system::error_code& ec, std::size_t) {
             (this->*response_func_ptr)(response, ec);
         });
     }
@@ -1135,7 +1135,7 @@ will_deref_and_erase_t asio_server_connection::handle_write_chunked_response(con
     auto membuf = m_response_buf.prepare(ChunkSize + chunked_encoding::additional_encoding_space);
 
     readbuf.getn(buffer_cast<uint8_t*>(membuf) + chunked_encoding::data_offset, ChunkSize)
-        .then([=](pplx::task<size_t> actualSizeTask) -> will_deref_and_erase_t {
+        .then([=, this](pplx::task<size_t> actualSizeTask) -> will_deref_and_erase_t {
             size_t actualSize = 0;
             try
             {
@@ -1168,7 +1168,7 @@ will_deref_and_erase_t asio_server_connection::handle_write_large_response(const
             response, std::make_exception_ptr(http_exception("Response stream close early!")));
     size_t readBytes = (std::min)(ChunkSize, m_write_size - m_write);
     readbuf.getn(buffer_cast<uint8_t*>(m_response_buf.prepare(readBytes)), readBytes)
-        .then([=](pplx::task<size_t> actualSizeTask) -> will_deref_and_erase_t {
+        .then([=, this](pplx::task<size_t> actualSizeTask) -> will_deref_and_erase_t {
             size_t actualSize = 0;
             try
             {
